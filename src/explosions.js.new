// === Core Flash Sparks (replaces the Sprite) ===
  let coreSparks = null;
  if (coreFlash) {
    const coreSparksCount = 100;
    const coreSparkGeo = new THREE.BufferGeometry();
    const csPos = new Float32Array(coreSparksCount * 3);
    const csVel = new Float32Array(coreSparksCount * 3);
    const csLife = new Float32Array(coreSparksCount);
    const csMax = new Float32Array(coreSparksCount);
    const csSize = new Float32Array(coreSparksCount);

    for (let i = 0; i < coreSparksCount; i++) {
      const sp = randRange(20, 80); // Slow speed for a tight core
      const vec = new THREE.Vector3().randomDirection().multiplyScalar(sp);

      csPos[i * 3 + 0] = x;
      csPos[i * 3 + 1] = y;
      csPos[i * 3 + 2] = 0;

      csVel[i * 3 + 0] = vec.x;
      csVel[i * 3 + 1] = vec.y;
      csVel[i * 3 + 2] = vec.z;

      const life = randRange(0.15, 0.3); // Very short life
      csLife[i] = life;
      csMax[i] = life;
      csSize[i] = randRange(1.5, 2.8);
    }

    coreSparkGeo.setAttribute("position", new THREE.BufferAttribute(csPos, 3));
    coreSparkGeo.setAttribute("aLife", new THREE.BufferAttribute(csLife, 1));
    coreSparkGeo.setAttribute("aMaxLife", new THREE.BufferAttribute(csMax, 1));
    coreSparkGeo.setAttribute("aSize", new THREE.BufferAttribute(csSize, 1));

    const coreSparkMat = new THREE.ShaderMaterial({
      transparent: true,
      depthWrite: false,
      blending: THREE.AdditiveBlending,
      uniforms: {},
      vertexShader: `
        attribute float aLife, aMaxLife, aSize;
        varying float vLifeFrac;
        void main() {
          vLifeFrac = clamp(aLife / max(0.0001, aMaxLife), 0.0, 1.0);
          vec4 mv = modelViewMatrix * vec4(position, 1.0);
          gl_Position = projectionMatrix * mv;
          gl_PointSize = aSize * (200.0 / -mv.z);
        }
      `,
      fragmentShader: `
        varying float vLifeFrac;
        void main() {
          float r = length(gl_PointCoord * 2.0 - 1.0);
          float alpha = smoothstep(1.0, 0.4, r);
          alpha *= (1.0 - vLifeFrac);
          gl_FragColor = vec4(vec3(1.0), alpha);
        }
      `,
    });

    coreSparks = new THREE.Points(coreSparkGeo, coreSparkMat);
    coreSparks.renderOrder = 3; // Render on top
    scene.add(coreSparks);

    // Add update logic for coreSparks in the tick function
    const coreSparksTick = (dt) => {
      const posAttr = coreSparkGeo.getAttribute("position");
      const lifeAttr = coreSparkGeo.getAttribute("aLife");
      const parr = posAttr.array;
      const larr = lifeAttr.array;
      let allDead = true;

      for (let i = 0; i < coreSparksCount; i++) {
        if (larr[i] <= 0) continue;
        allDead = false;
        larr[i] -= dt;

        parr[i * 3 + 0] += csVel[i * 3 + 0] * dt;
        parr[i * 3 + 1] += csVel[i * 3 + 1] * dt;
        parr[i * 3 + 2] += csVel[i * 3 + 2] * dt;
      }
      posAttr.needsUpdate = true;
      lifeAttr.needsUpdate = true;

      if (allDead) {
        scene.remove(coreSparks);
        coreSparkGeo.dispose();
        coreSparkMat.dispose();
        coreSparks = null;
        return false; // Signal to stop ticking
      }
      return true; // Continue ticking
    };
    
    // Store the tick function to be called from the main loop
    coreSparks.userData.tick = coreSparksTick;
  }

  // === Chispas (núcleo blanco, brillo constante) ===
  const sparkGeo = new THREE.BufferGeometry();
  const sPos = new Float32Array(sparksCount * 3);
  const sVel = new Float32Array(sparksCount * 3); // Now 3D
  const sLife = new Float32Array(sparksCount);
  const sMax = new Float32Array(sparksCount);
  const sSize = new Float32Array(sparksCount);
  const sCol = new Float32Array(sparksCount * 3);
  const sMass = new Float32Array(sparksCount);

  for (let i = 0; i < sparksCount; i++) {
    const sp = randRange(300, 740);
    const vec = new THREE.Vector3().randomDirection().multiplyScalar(sp);

    const off = randRange(10, 18);
    
    sPos[i * 3 + 0] = x + vec.x / sp * off;
    sPos[i * 3 + 1] = y + vec.y / sp * off;
    sPos[i * 3 + 2] = 0 + vec.z / sp * off;

    sVel[i * 3 + 0] = vec.x;
    sVel[i * 3 + 1] = vec.y;
    sVel[i * 3 + 2] = vec.z;

    const life = randRange(0.7, 1.25);
    sLife[i] = life;
    sMax[i] = life;
    sSize[i] = randRange(4.2, 5.6);
    sMass[i] = randRange(0.7, 1.3);

    const hue = rainbowSparks ? (i / sparksCount) : paletteHue(i, sparksCount, palette);
    const sat = paletteSaturation(palette);
    const c = hslColor(hue, sat, 0.56); // luz fija para evitar tonos oscuros
    sCol[i * 3 + 0] = c.r; sCol[i * 3 + 1] = c.g; sCol[i * 3 + 2] = c.b;
  }

  sparkGeo.setAttribute("position", new THREE.BufferAttribute(sPos, 3));
  sparkGeo.setAttribute("color", new THREE.BufferAttribute(sCol, 3));
  sparkGeo.setAttribute("aLife", new THREE.BufferAttribute(sLife, 1));
  sparkGeo.setAttribute("aMaxLife", new THREE.BufferAttribute(sMax, 1));
  sparkGeo.setAttribute("aSize", new THREE.BufferAttribute(sSize, 1));

  const sparkMat = new THREE.ShaderMaterial({
    transparent: true,
    depthWrite: false,
    depthTest: false,
    blending: THREE.AdditiveBlending,
    uniforms: { uOpacity: { value: 1.0 } },
    vertexColors: true,
    vertexShader: `
      attribute float aLife, aMaxLife, aSize;
      varying float vLifeFrac;
      varying vec3 vColor;
      void main() {
        vLifeFrac = clamp(aLife / max(0.0001, aMaxLife), 0.0, 1.0);
        vColor = color;
        vec4 mv = modelViewMatrix * vec4(position, 1.0);
        gl_Position = projectionMatrix * mv;
        float size = aSize * (0.85 + 0.55 * smoothstep(0.0, 0.3, vLifeFrac)) * (0.9 + 0.5 * vLifeFrac) * (300.0 / -mv.z);
        gl_PointSize = size;
      }
    `,
    fragmentShader: `
      varying float vLifeFrac;
      varying vec3 vColor;
      uniform float uOpacity;
      void main() {
        vec2 uv = gl_PointCoord * 2.0 - 1.0;
        float r = length(uv);
        float alpha = smoothstep(1.0, 0.0, r);
        alpha = pow(alpha, 1.6);
        // mantén color brillante; leve viraje cálido al final
        vec3 warm = mix(vColor, vec3(1.0, 0.62, 0.25), 0.6 * (1.0 - vLifeFrac));
        float core = pow(1.0 - r, 3.0);
        vec3 col = mix(warm, vec3(1.0), core * 0.55);
        gl_FragColor = vec4(col, alpha * uOpacity);
      }
    `,
  });
  const sparks = new THREE.Points(sparkGeo, sparkMat);
  sparks.renderOrder = 2;
  scene.add(sparks);

  // === Humo (más grande y visible) ===
  const smokeCount = options.smokeCount ?? 70;
  const smokeGeo = new THREE.BufferGeometry();
  const mPos = new Float32Array(smokeCount * 3);
  const mVel = new Float32Array(smokeCount * 2);
  const mLife = new Float32Array(smokeCount);
  const mMax = new Float32Array(smokeCount);
  const mSize = new Float32Array(smokeCount);

  for (let i = 0; i < smokeCount; i++) {
    const ang = randRange(0, Math.PI * 2);
    const rad = randRange(4, 14);
    const dx = Math.cos(ang), dy = Math.sin(ang);

    mPos[i * 3 + 0] = x + dx * rad;
    mPos[i * 3 + 1] = y + dy * rad;
    mPos[i * 3 + 2] = 0;

    const up = yDown ? -1 : +1;
    mVel[i * 2 + 0] = dx * randRange(8, 22);
    mVel[i * 2 + 1] = up * randRange(26, 44);

    const life = randRange(1.6, 3.2);
    mLife[i] = life; mMax[i] = life;
    mSize[i] = randRange(18, 32);
  }

  smokeGeo.setAttribute("position", new THREE.BufferAttribute(mPos, 3));
  smokeGeo.setAttribute("aLife", new THREE.BufferAttribute(mLife, 1));
  smokeGeo.setAttribute("aMaxLife", new THREE.BufferAttribute(mMax, 1));
  smokeGeo.setAttribute("aSize", new THREE.BufferAttribute(mSize, 1));

  const smokeMat = new THREE.ShaderMaterial({
    transparent: true,
    depthWrite: false,
    depthTest: false,
    blending: THREE.NormalBlending, // niebla visible sin "apagar" el fondo
    uniforms: { uOpacity: { value: 0.95 } },
    vertexShader: `
      attribute float aLife, aMaxLife, aSize;
      varying float vLifeFrac;
      void main() {
        vLifeFrac = clamp(aLife / max(0.0001, aMaxLife), 0.0, 1.0);
        vec4 mv = modelViewMatrix * vec4(position, 1.0);
        gl_Position = projectionMatrix * mv;
        gl_PointSize = aSize * (0.9 + 1.7 * (1.0 - vLifeFrac));
      }
    `,
    fragmentShader: `
      varying float vLifeFrac;
      uniform float uOpacity;
      void main() {
        vec2 uv = gl_PointCoord * 2.0 - 1.0;
        float r = length(uv);
        float alpha = smoothstep(1.0, 0.0, r);
        alpha = pow(alpha, 3.0);
        float g = mix(0.35, 0.55, vLifeFrac);
        gl_FragColor = vec4(vec3(g), alpha * uOpacity * vLifeFrac);
      }
    `,
  });
  const smoke = new THREE.Points(smokeGeo, smokeMat);
  smoke.renderOrder = 0.8;
  scene.add(smoke);

  // Audio + micro shake
  try { audioFns?.boom?.(x, y); } catch {}
  const shakeStart = performance.now();
  const origPos = camera.position.clone();
  (function shake() {
    const e = performance.now() - shakeStart;
    const t = Math.min(1, e / 120), d = 1 - t;
    camera.position.x = origPos.x + (Math.random() - 0.5) * 6 * d;
    camera.position.y = origPos.y + (Math.random() - 0.5) * 6 * d;
    camera.updateProjectionMatrix();
    if (t < 1) requestAnimationFrame(shake);
    else camera.position.copy(origPos);
  })();

  const start = performance.now();
  let last = start;
  let cracked = false;

  function tick() {
    const now = performance.now();
    const dt = Math.min(0.033, (now - last) / 1000);
    const tsec = (now - start) / 1000;
    last = now;

    // Update core sparks
    if (coreSparks && coreSparks.userData.tick) {
      const stillAlive = coreSparks.userData.tick(dt);
      if (!stillAlive) {
        coreSparks.userData.tick = null; // Stop trying to tick it
      }
    }

    // fade sólo después de que terminó la curva
    const tSinceCurve = Math.max(0, tsec - curveEndSec);
    const fadeFactor = Math.max(0, 1 - tSinceCurve / fadeAfterCurveSec);

    // actualizar resoluciones ante resize
    const rw = renderer.domElement.width, rh = renderer.domElement.height;
    if (linesMat.resolution.x !== rw || linesMat.resolution.y !== rh) {
      linesMat.resolution.set(rw, rh);
    }
    if (haloMat.resolution.x !== rw || haloMat.resolution.y !== rh) {
      haloMat.resolution.set(rw, rh);
    }

    // fase recta/curva
    let gScale = 0.0;
    if (tsec > straightPhaseSec) {
      const tt = (tsec - straightPhaseSec) / Math.max(0.0001, curveInSec);
      gScale = smoothstep(0, 1, tt);
    }

    // Integración cabezas
    for (let i = 0; i < SPOKES; i++) {
      const base = i * SEGMENTS * 3;
      const hx = trails.tail[base + 0], hy = trails.tail[base + 1], hz = trails.tail[base + 2];

      let vx = vel[i * 3 + 0], vy = vel[i * 3 + 1], vz = vel[i * 3 + 2];

      vy += gSign * GRAV * gScale * dt * particleMass[i];

      const vlen = Math.max(1e-3, Math.sqrt(vx*vx + vy*vy + vz*vz));
      
      // Simple curl noise, can be improved
      const curlK = curlStrength * Math.pow(curlDecay, tsec * 4) * curlSign[i];
      const noiseVec = new THREE.Vector3(
          Math.sin(curlPhase[i] + i * 0.37),
          Math.cos(curlPhase[i] * 0.7 + i * 1.9),
          Math.sin(curlPhase[i] * 1.3 + i * 0.8)
      ).normalize().multiplyScalar(curlK);

      vx += noiseVec.x;
      vy += noiseVec.y;
      vz += noiseVec.z;

      curlPhase[i] += dt * 6.0;
      
      const dragFactor = Math.pow(DRAG, particleMass[i]);
      vx *= dragFactor; 
      vy *= dragFactor;
      vz *= dragFactor;

      const nxp = hx + vx * dt;
      const nyp = hy + vy * dt;
      const nzp = hz + vz * dt;

      vel[i * 3 + 0] = vx;
      vel[i * 3 + 1] = vy;
      vel[i * 3 + 2] = vz;

      trails.pushHead(i, nxp, nyp, nzp);
    }

    trails.bakeDrawPositions();
    linesGeom.setPositions(trails.drawPos);

    // Color trail multicolor (mantener brillo)
    const segs = SEGMENTS - 1;
    for (let i = 0; i < SPOKES; i++) {
      const baseHue = hueSeed[i];
      const hueTime = baseHue + Math.sin(tsec * 1.8 + i * 0.13) * 0.03;
      const light = keepBrightColors ? trailLightBase : (trailLightBase - 0.28 * Math.min(1, tsec / LIFE_S));
      const tint = hslColor(hueTime, paletteSaturation(palette), light).multiplyScalar(
        1.0 + Math.sin(i * 2.3 + tsec * 24) * 0.04
      );

      for (let k = 0; k < segs; k++) {
        const posFrac = k / segs;
        let bright = keepBrightColors
          ? Math.max(minBrightness, 0.85 * posFrac)
          : Math.max(minBrightness, posFrac * Math.pow(1 - tsec / LIFE_S, 2) * 2.0);

        const headBoost = 1.0 + (1.0 - posFrac) * 0.28;

        const r = tint.r * bright * headBoost;
        const g = tint.g * bright * headBoost;
        const b = tint.b * bright * headBoost;

        const idx = (i * segs + k) * 2 * 3;
        colors[idx + 0] = r; colors[idx + 1] = g; colors[idx + 2] = b;
        colors[idx + 3] = r; colors[idx + 4] = g; colors[idx + 5] = b;
      }
    }
    linesGeom.setColors(colors);

    // Shockwave anim
    if (ringMesh) {
      const rt = Math.min(1, tsec / 0.85); // Slower expansion
      const s = 0.15 + rt * 5.5;
      ringMesh.scale.set(s, s, 1);
      ringMesh.material.opacity = (1 - rt) * 0.7;
      if (rt >= 1) {
        scene.remove(ringMesh);
        ringMesh.geometry.dispose();
        ringMesh.material.dispose();
        ringMesh = null;
      }
    }

    // Chispas
    {
      const posAttr = sparkGeo.getAttribute("position");
      const lifeAttr = sparkGeo.getAttribute("aLife");
      const colAttr = sparkGeo.getAttribute("color");
      const parr = posAttr.array;
      const carr = colAttr.array;
      const larr = lifeAttr.array;

      for (let i = 0; i < sparksCount; i++) {
        if (larr[i] <= 0) continue;
        larr[i] -= dt;

        // gravedad más fuerte en chispas
        sVel[i * 3 + 1] += gSign * GRAV * sparksGravMul * dt * sMass[i];
        
        const drag = Math.pow(0.94, sMass[i]);
        sVel[i * 3 + 0] *= drag;
        sVel[i * 3 + 1] *= drag;
        sVel[i * 3 + 2] *= drag;

        parr[i * 3 + 0] += sVel[i * 3 + 0] * dt;
        parr[i * 3 + 1] += sVel[i * 3 + 1] * dt;
        parr[i * 3 + 2] += sVel[i * 3 + 2] * dt;

        // mantiene colores vivos; leve corrimiento a cálidos al final
        const baseHue = rainbowSparks ? (i / sparksCount) : paletteHue(i, sparksCount, palette);
        const lifeFrac = Math.max(0, Math.min(1, larr[i] / sMax[i]));
        const hue = baseHue + 0.06 * (1.0 - lifeFrac);
        const c = hslColor(hue, paletteSaturation(palette), 0.56);
        carr[i * 3 + 0] = c.r; carr[i * 3 + 1] = c.g; carr[i * 3 + 2] = c.b;

        larr[i] -= dt;
      }
      // desvanecen por opacidad, después de la curva
      sparkMat.uniforms.uOpacity.value = fadeFactor;
      posAttr.needsUpdate = true;
      colAttr.needsUpdate = true;
      lifeAttr.needsUpdate = true;
    }

    // Humo (más visible, fade después de curva)
    {
      const posAttr = smokeGeo.getAttribute("position");
      const lifeAttr = smokeGeo.getAttribute("aLife");
      const parr = posAttr.array;
      const larr = lifeAttr.array;

      for (let i = 0; i < smokeCount; i++) {
        if (larr[i] <= 0) continue;

        mVel[i * 2 + 0] *= 0.985;
        mVel[i * 2 + 1] *= 0.985;

        parr[i * 3 + 0] += mVel[i * 2 + 0] * dt;
        parr[i * 3 + 1] += mVel[i * 2 + 1] * dt;

        larr[i] -= dt;
      }
      posAttr.needsUpdate = true;
      lifeAttr.needsUpdate = true;

      smokeMat.uniforms.uOpacity.value = 0.95 * fadeFactor;
    }

    // Crackles
    if (!cracked && tsec > 0.35) {
      cracked = true;
      const N = 1 + Math.floor(Math.random() * 2);
      for (let i = 0; i < N; i++) {
        try { audioFns?.crackle?.(x + randRange(-12, 12), y + randRange(-12, 12)); } catch {}
      }
    }

    // Pulso global y opacidad por fadeFactor
    const pulse = 1 + Math.sin(tsec * 28) * 0.07;
    linesMat.linewidth = LINE_W * pulse;
    haloMat.linewidth  = (LINE_W * 2.4) * pulse;

    linesMat.opacity = fadeFactor;
    haloMat.opacity  = 0.32 * fadeFactor;
    linesMat.needsUpdate = true;
    haloMat.needsUpdate  = true;

    // Micro-flicker clamped (no baja de 1.0)
    if (renderer.toneMappingExposure !== undefined) {
      const amp = 0.012 * (1.0 - Math.min(1, tsec / 0.5));
      const s = Math.sin(tsec * 85.0);
      const flick = 1.0 + Math.max(0.0, s) * amp; // nunca por debajo de 1.0
      renderer.toneMappingExposure = flick;
    }

    if (tsec < LIFE_S) requestAnimationFrame(tick);
    else {
      // Limpieza
      scene.remove(lines);  linesGeom.dispose(); linesMat.dispose();
      scene.remove(halo);   haloMat.dispose();
      scene.remove(sparks); sparkGeo.dispose(); sparkMat.dispose();
      if (ringMesh) { scene.remove(ringMesh); ringMesh.geometry.dispose(); ringMesh.material.dispose(); }
      scene.remove(smoke); smokeGeo.dispose(); smokeMat.dispose();
    }
  }
  requestAnimationFrame(tick);
}
